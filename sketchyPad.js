// Generated by CoffeeScript 1.6.3
(function() {
  var Renderer, SketchListener, SketchyPad, root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SketchListener = (function() {
    function SketchListener(opts) {
      this.onCanvasMouseUp = __bind(this.onCanvasMouseUp, this);
      this.onCanvasMouseMove = __bind(this.onCanvasMouseMove, this);
      this.getMouseCoord = __bind(this.getMouseCoord, this);
      this.onCanvasMouseDown = __bind(this.onCanvasMouseDown, this);
      this.onCanvasMouseOut = __bind(this.onCanvasMouseOut, this);
      this.onCanvasMouseHover = __bind(this.onCanvasMouseHover, this);
      this.removeCallback = __bind(this.removeCallback, this);
      this.addCallback = __bind(this.addCallback, this);
      this.stop = __bind(this.stop, this);
      this.start = __bind(this.start, this);
      this.$canvas = $('<canvas>', opts).attr('width', opts['width']).attr('height', opts['height']);
      this.width = this.$canvas.width();
      this.height = this.$canvas.height();
      this.callbacks = {
        onCanvasMouseHover: [],
        onCanvasMouseDown: [],
        onCanvasMouseMove: [],
        onCanvasMouseUp: [],
        onCanvasMouseOut: []
      };
      this.mouseCoord = {
        x: 0,
        y: 0
      };
      this.touchSupported = (__indexOf.call(window, 'ontouchstart') >= 0);
    }

    SketchListener.prototype.start = function() {
      if (this.touchSupported) {
        this.mouseDownEvent = "touchstart";
        this.mouseMoveEvent = "touchmove";
        this.mouseUpEvent = "touchend";
      } else {
        this.mouseDownEvent = "mousedown";
        this.mouseMoveEvent = "mousemove";
        this.mouseUpEvent = "mouseup";
        this.$canvas.bind(this.mouseMoveEvent, this.onCanvasMouseHover);
        this.$canvas.bind('mouseout', this.onCanvasMouseOut);
      }
      this.$canvas.bind(this.mouseDownEvent, this.onCanvasMouseDown);
      return console.log('listening started');
    };

    SketchListener.prototype.stop = function() {
      this.$canvas.unbind();
      return console.log('listening stopped');
    };

    SketchListener.prototype.addCallback = function(eventName, func) {
      return this.callbacks[eventName].push(func);
    };

    SketchListener.prototype.removeCallback = function(eventName, func) {
      var indexOfCallback;
      indexOfCallback = this.callbacks[eventName].indexOf(func);
      return this.callbacks[eventName].splice(indexOfCallback, 1);
    };

    SketchListener.prototype.onCanvasMouseHover = function(event) {
      var callback, _i, _len, _ref, _results;
      this.getMouseCoord(event);
      console.log('hovering');
      _ref = this.callbacks['onCanvasMouseHover'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback.call());
      }
      return _results;
    };

    SketchListener.prototype.onCanvasMouseOut = function(event) {
      var callback, _i, _len, _ref, _results;
      console.log('mouse out');
      _ref = this.callbacks['onCanvasMouseOut'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback.call());
      }
      return _results;
    };

    SketchListener.prototype.onCanvasMouseDown = function(event) {
      var callback, _i, _len, _ref;
      this.getMouseCoord(event);
      console.log('mouse down');
      _ref = this.callbacks['onCanvasMouseDown'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      if (!this.touchSupported) {
        this.$canvas.unbind(this.mouseMoveEvent, this.onCanvasMouseHover);
      }
      $(document).bind(this.mouseMoveEvent, this.onCanvasMouseMove);
      return $(document).bind(this.mouseUpEvent, this.onCanvasMouseUp);
    };

    SketchListener.prototype.getMouseCoord = function(event) {
      var offset, target;
      if (this.touchSupported) {
        target = event.originalEvent.touches[0];
      } else {
        target = event;
      }
      offset = this.$canvas.offset();
      this.mouseCoord.x = Math.round(target.pageX - offset.left);
      return this.mouseCoord.y = Math.round(target.pageY - offset.top);
    };

    SketchListener.prototype.onCanvasMouseMove = function(event) {
      var callback, _i, _len, _ref;
      this.getMouseCoord(event);
      console.log('mouse move');
      _ref = this.callbacks['onCanvasMouseMove'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      event.preventDefault();
      return false;
    };

    SketchListener.prototype.onCanvasMouseUp = function(event) {
      var callback, _i, _len, _ref;
      console.log('mouse up');
      _ref = this.callbacks['onCanvasMouseUp'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      $(document).unbind(this.mouseMoveEvent, this.onCanvasMouseMove);
      $(document).unbind(this.mouseUpEvent, this.onCanvasMouseUp);
      if (!this.touchSupported) {
        return this.$canvas.bind(this.mouseMoveEvent, this.onCanvasMouseHover);
      }
    };

    return SketchListener;

  })();

  Renderer = (function() {
    function Renderer() {}

    Renderer.apply = function(layer, instruction) {
      var context;
      return context = layer[0].getContext('2d');
    };

    Renderer.clear = function(ctx, width, height) {
      return ctx.clearRect(0, 0, width, height);
    };

    Renderer.drawStroke = function(ctx, stroke) {
      var color, index, point, points, size, x, xc, y, yc, _i, _j, _len, _len1, _ref, _ref1;
      color = stroke[0];
      size = stroke[1];
      points = stroke[2];
      if (color === null) {
        ctx.globalCompositeOperation = "destination-out";
        color = 'rgba(255,255,255,1)';
      } else {
        ctx.globalCompositeOperation = "source-over";
      }
      x = points[0][0];
      y = points[0][1];
      if (points.length === 1) {
        ctx.beginPath();
        ctx.arc(x, y, size / 2, 0, Math.PI * 2, true);
        ctx.fillStyle = color;
        ctx.fill();
      } else if (points.length < 6) {
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        _ref = points.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          x = point[0];
          y = point[1];
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      } else {
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y);
        index = 1;
        _ref1 = points.slice(1, +(points.length - 2) + 1 || 9e9);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          point = _ref1[_j];
          x = point[0];
          y = point[1];
          xc = (x + points[index + 1][0]) / 2;
          yc = (y + points[index + 1][1]) / 2;
          ctx.quadraticCurveTo(x, y, xc, yc);
          index++;
        }
        ctx.quadraticCurveTo(points[index - 1][0], points[index - 1][1], points[index][0], points[index][1]);
        ctx.stroke();
      }
    };

    Renderer.applyStrokes = function(ctx, strokes) {
      var stroke, _i, _len;
      for (_i = 0, _len = strokes.length; _i < _len; _i++) {
        stroke = strokes[_i];
        this.drawStroke(ctx, stroke);
      }
    };

    Renderer.playStrokes = function(onion_skin, $transport, strokes, stroke_index, point_index, timer, callback) {
      var ctx, delay, draw_to, height, new_timer, next_point_index, next_stroke_index, width,
        _this = this;
      if (stroke_index == null) {
        stroke_index = 0;
      }
      if (point_index == null) {
        point_index = 0;
      }
      if (timer == null) {
        timer = null;
      }
      ctx = onion_skin.feedback_ctx;
      width = onion_skin.width;
      height = onion_skin.height;
      if (timer) {
        window.clearInterval(timer);
      }
      draw_to = JSON.parse(JSON.stringify(strokes));
      draw_to = draw_to.slice(0, +stroke_index + 1 || 9e9);
      draw_to[draw_to.length - 1][2] = draw_to[draw_to.length - 1][2].slice(0, +point_index + 1 || 9e9);
      this.clear(ctx, width, height);
      this.applyStrokes(ctx, draw_to);
      if (point_index < strokes[stroke_index][2].length - 1) {
        next_point_index = point_index + 1;
        next_stroke_index = stroke_index;
        delay = strokes[next_stroke_index][2][next_point_index][2] - strokes[stroke_index][2][point_index][2];
      } else if (stroke_index < strokes.length - 1) {
        next_stroke_index = stroke_index + 1;
        next_point_index = 0;
        delay = 200;
      } else {
        callback.call();
        return;
      }
      if ($transport.hasClass('playing')) {
        new_timer = window.setInterval(function() {
          return _this.playStrokes(onion_skin, $transport, strokes, next_stroke_index, next_point_index, new_timer, callback);
        }, delay);
      } else {
        this.clear(ctx, width, height);
        this.applyStrokes(ctx, strokes);
        callback.call();
      }
    };

    return Renderer;

  })();

  SketchyPad = (function() {
    function SketchyPad(opts) {
      this.reset = __bind(this.reset, this);
      this.refresh = __bind(this.refresh, this);
      this.process_mouse_up = __bind(this.process_mouse_up, this);
      this.process_mouse_move = __bind(this.process_mouse_move, this);
      this.process_mouse_down = __bind(this.process_mouse_down, this);
      this.show_tool_size = __bind(this.show_tool_size, this);
      this.captureStop = __bind(this.captureStop, this);
      this.captureStart = __bind(this.captureStart, this);
      this.sketch_listener = new SketchListener(opts);
      this.$canvas = this.sketch_listener.$canvas;
      this.feedback_ctx = this.$canvas[0].getContext('2d');
      this.feedback_ctx.lineCap = 'round';
      this.sketch_listener.addCallback('onCanvasMouseHover', this.show_tool_size);
      this.sketch_listener.addCallback('onCanvasMouseOut', this.refresh);
      this.width = this.sketch_listener.width;
      this.height = this.sketch_listener.height;
      this.strokeData = [];
      this.sketchData = [];
      this.redoData = [];
      this.selected_tool = '#ff0000';
      this.tool_size = 1;
      this.sketch_listener.addCallback('onCanvasMouseUp', this.process_mouse_up);
      this.sketch_listener.addCallback('onCanvasMouseMove', this.process_mouse_move);
      this.sketch_listener.addCallback('onCanvasMouseDown', this.process_mouse_down);
    }

    SketchyPad.prototype.captureStart = function() {
      return this.sketch_listener.start();
    };

    SketchyPad.prototype.captureStop = function() {
      return this.sketch_listener.stop();
    };

    SketchyPad.prototype.show_tool_size = function() {
      if (this.selected_tool) {
        this.$canvas.addClass('brush');
        this.$canvas.removeClass('eraser');
      } else {
        this.$canvas.addClass('eraser');
        this.$canvas.removeClass('brush');
      }
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
      return Renderer.drawStroke(this.feedback_ctx, [this.selected_tool, this.tool_size, [[this.sketch_listener.mouseCoord.x, this.sketch_listener.mouseCoord.y, null]]]);
    };

    SketchyPad.prototype.process_mouse_down = function() {
      this.redoData = [];
      this.startTime = new Date().getTime();
      this.strokeData.push([this.sketch_listener.mouseCoord.x, this.sketch_listener.mouseCoord.y, 0]);
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
      return Renderer.drawStroke(this.feedback_ctx, [this.selected_tool, this.tool_size, this.strokeData]);
    };

    SketchyPad.prototype.process_mouse_move = function() {
      this.elapsed_time = (new Date().getTime()) - this.startTime;
      this.strokeData.push([this.sketch_listener.mouseCoord.x, this.sketch_listener.mouseCoord.y, this.elapsed_time]);
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
      return Renderer.drawStroke(this.feedback_ctx, [this.selected_tool, this.tool_size, this.strokeData]);
    };

    SketchyPad.prototype.process_mouse_up = function() {
      this.sketchData.push([this.selected_tool, this.tool_size, this.strokeData]);
      return this.strokeData = [];
    };

    SketchyPad.prototype.refresh = function() {
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      return Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
    };

    SketchyPad.prototype.reset = function() {
      this.sketchData = [];
      return this.strokeData = [];
    };

    return SketchyPad;

  })();

  root.SketchListener = SketchListener;

  root.SketchyPad = SketchyPad;

}).call(this);
