// Generated by CoffeeScript 1.6.3
(function() {
  var Renderer, SketchData, SketchListener, SketchStroke, SketchView, SketchyPad, root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SketchData = (function() {
    function SketchData() {
      this.strokes = [];
    }

    SketchData.prototype.addStroke = function(stroke) {
      return this.strokes.push(stroke);
    };

    return SketchData;

  })();

  SketchStroke = (function() {
    function SketchStroke() {
      this.color = 'rgba(255,0,0,0.5)';
      this.points = [];
      this.pressures = [];
      this.timestamps = [];
    }

    SketchStroke.prototype.addData = function(point, pressure) {
      this.points.push(point);
      this.pressures.push(pressure);
      return this.timestamps.push(Time.now);
    };

    return SketchStroke;

  })();

  SketchView = (function() {
    function SketchView(opts) {
      this.$canvas = $('<canvas>', opts).attr('width', opts['width']).attr('height', opts['height']);
      this.width = this.$canvas.width();
      this.height = this.$canvas.height();
      this.ctx = this.$canvas[0].getContext('2d');
      this.ctx.globalCompositeOperation = "source-over";
    }

    SketchView.prototype.drawStroke = function(stroke) {};

    SketchView.prototype.drawStrokes = function(strokes) {};

    SketchView.prototype.playbackStrokes = function(strokes) {};

    SketchView.prototype.clear = function() {};

    return SketchView;

  })();

  SketchListener = (function() {
    function SketchListener(element) {
      this.onCanvasMouseUp = __bind(this.onCanvasMouseUp, this);
      this.onCanvasMouseMove = __bind(this.onCanvasMouseMove, this);
      this.getMouseCoord = __bind(this.getMouseCoord, this);
      this.onCanvasMouseDown = __bind(this.onCanvasMouseDown, this);
      this.onCanvasMouseOut = __bind(this.onCanvasMouseOut, this);
      this.onCanvasMouseHover = __bind(this.onCanvasMouseHover, this);
      this.removeCallback = __bind(this.removeCallback, this);
      this.addCallback = __bind(this.addCallback, this);
      this.stop = __bind(this.stop, this);
      this.start = __bind(this.start, this);
      this.$element = element;
      this.callbacks = {
        onCanvasMouseHover: [],
        onCanvasMouseDown: [],
        onCanvasMouseMove: [],
        onCanvasMouseUp: [],
        onCanvasMouseOut: []
      };
      this.mouseCoord = [0, 0];
      this.touchSupported = (__indexOf.call(window, 'ontouchstart') >= 0);
    }

    SketchListener.prototype.start = function() {
      if (this.touchSupported) {
        this.mouseDownEvent = "touchstart";
        this.mouseMoveEvent = "touchmove";
        this.mouseUpEvent = "touchend";
      } else {
        this.mouseDownEvent = "mousedown";
        this.mouseMoveEvent = "mousemove";
        this.mouseUpEvent = "mouseup";
        this.$element.bind(this.mouseMoveEvent, this.onCanvasMouseHover);
        this.$element.bind('mouseout', this.onCanvasMouseOut);
      }
      return this.$element.bind(this.mouseDownEvent, this.onCanvasMouseDown);
    };

    SketchListener.prototype.stop = function() {
      return this.$element.unbind();
    };

    SketchListener.prototype.addCallback = function(eventName, func) {
      return this.callbacks[eventName].push(func);
    };

    SketchListener.prototype.removeCallback = function(eventName, func) {
      var indexOfCallback;
      indexOfCallback = this.callbacks[eventName].indexOf(func);
      return this.callbacks[eventName].splice(indexOfCallback, 1);
    };

    SketchListener.prototype.onCanvasMouseHover = function(event) {
      var callback, _i, _len, _ref, _results;
      this.getMouseCoord(event);
      _ref = this.callbacks['onCanvasMouseHover'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback.call());
      }
      return _results;
    };

    SketchListener.prototype.onCanvasMouseOut = function(event) {
      var callback, _i, _len, _ref, _results;
      _ref = this.callbacks['onCanvasMouseOut'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback.call());
      }
      return _results;
    };

    SketchListener.prototype.onCanvasMouseDown = function(event) {
      var callback, _i, _len, _ref;
      this.getMouseCoord(event);
      _ref = this.callbacks['onCanvasMouseDown'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      if (!this.touchSupported) {
        this.$element.unbind(this.mouseMoveEvent, this.onCanvasMouseHover);
      }
      $(document).bind(this.mouseMoveEvent, this.onCanvasMouseMove);
      return $(document).bind(this.mouseUpEvent, this.onCanvasMouseUp);
    };

    SketchListener.prototype.getMouseCoord = function(event) {
      var offset, target;
      if (this.touchSupported) {
        target = event.originalEvent.touches[0];
      } else {
        target = event;
      }
      offset = this.$element.offset();
      this.mouseCoord.x = Math.round(target.pageX - offset.left);
      return this.mouseCoord.y = Math.round(target.pageY - offset.top);
    };

    SketchListener.prototype.onCanvasMouseMove = function(event) {
      var callback, _i, _len, _ref;
      this.getMouseCoord(event);
      _ref = this.callbacks['onCanvasMouseMove'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      event.preventDefault();
      return false;
    };

    SketchListener.prototype.onCanvasMouseUp = function(event) {
      var callback, _i, _len, _ref;
      _ref = this.callbacks['onCanvasMouseUp'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.call();
      }
      $(document).unbind(this.mouseMoveEvent, this.onCanvasMouseMove);
      $(document).unbind(this.mouseUpEvent, this.onCanvasMouseUp);
      if (!this.touchSupported) {
        return this.$element.bind(this.mouseMoveEvent, this.onCanvasMouseHover);
      }
    };

    return SketchListener;

  })();

  Renderer = (function() {
    function Renderer() {}

    Renderer.apply = function(layer, instruction) {
      var context;
      return context = layer[0].getContext('2d');
    };

    Renderer.clear = function(ctx, width, height) {
      return ctx.clearRect(0, 0, width, height);
    };

    Renderer.drawDot = function(ctx, point) {
      var pressure, x, y;
      x = point[0];
      y = point[1];
      pressure = point[2];
      ctx.globalCompositeOperation = "source-over";
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2, true);
      ctx.fillStyle = 'rgba(255,0,0,0.5)';
      return ctx.fill();
    };

    Renderer.drawStroke = function(ctx, stroke) {
      var color, i, lastIndex, points, size, _i;
      color = stroke[0];
      size = stroke[1];
      points = stroke[2];
      if (color === null) {
        ctx.globalCompositeOperation = "destination-out";
        color = 'rgba(255,255,255,1)';
      } else {
        ctx.globalCompositeOperation = "source-over";
      }
      if (points.length >= 2) {
        ctx.beginPath();
        ctx.moveTo.apply(ctx, points[0]);
        lastIndex = points.length - 1;
        if (smoothConfig.clip === 'periodic') {
          lastIndex++;
        }
        for (i = _i = 0; 0 <= lastIndex ? _i < lastIndex : _i > lastIndex; i = 0 <= lastIndex ? ++_i : --_i) {
          addCurveSegment(cx, i, points);
        }
        cx.lineWidth = 2;
        cx.strokeStyle = '#0000ff';
        cx.lineJoin = 'round';
        cx.lineCap = 'round';
        cx.stroke();
      }
    };

    Renderer.applyStrokes = function(ctx, strokes) {
      var stroke, _i, _len;
      for (_i = 0, _len = strokes.length; _i < _len; _i++) {
        stroke = strokes[_i];
        this.drawStroke(ctx, stroke);
      }
    };

    Renderer.playStrokes = function(onion_skin, $transport, strokes, stroke_index, point_index, timer, callback) {
      var ctx, delay, draw_to, height, new_timer, next_point_index, next_stroke_index, width,
        _this = this;
      if (stroke_index == null) {
        stroke_index = 0;
      }
      if (point_index == null) {
        point_index = 0;
      }
      if (timer == null) {
        timer = null;
      }
      ctx = onion_skin.feedback_ctx;
      width = onion_skin.width;
      height = onion_skin.height;
      if (timer) {
        window.clearInterval(timer);
      }
      draw_to = JSON.parse(JSON.stringify(strokes));
      draw_to = draw_to.slice(0, +stroke_index + 1 || 9e9);
      draw_to[draw_to.length - 1][2] = draw_to[draw_to.length - 1][2].slice(0, +point_index + 1 || 9e9);
      this.clear(ctx, width, height);
      this.applyStrokes(ctx, draw_to);
      if (point_index < strokes[stroke_index][2].length - 1) {
        next_point_index = point_index + 1;
        next_stroke_index = stroke_index;
        delay = strokes[next_stroke_index][2][next_point_index][2] - strokes[stroke_index][2][point_index][2];
      } else if (stroke_index < strokes.length - 1) {
        next_stroke_index = stroke_index + 1;
        next_point_index = 0;
        delay = 200;
      } else {
        callback.call();
        return;
      }
      if ($transport.hasClass('playing')) {
        new_timer = window.setInterval(function() {
          return _this.playStrokes(onion_skin, $transport, strokes, next_stroke_index, next_point_index, new_timer, callback);
        }, delay);
      } else {
        this.clear(ctx, width, height);
        this.applyStrokes(ctx, strokes);
        callback.call();
      }
    };

    return Renderer;

  })();

  SketchyPad = (function() {
    function SketchyPad(opts) {
      this.reset = __bind(this.reset, this);
      this.refresh = __bind(this.refresh, this);
      this.process_mouse_up = __bind(this.process_mouse_up, this);
      this.process_mouse_move = __bind(this.process_mouse_move, this);
      this.process_mouse_down = __bind(this.process_mouse_down, this);
      this.show_tool_size = __bind(this.show_tool_size, this);
      this.captureStop = __bind(this.captureStop, this);
      this.captureStart = __bind(this.captureStart, this);
      this.getPressure = __bind(this.getPressure, this);
      this.$wacom_object = $('<object>', {
        id: 'wtPlugin',
        type: 'application/x-wacomtabletplugin'
      });
      this.$wacom_object.append($('<param>', {
        name: 'onload',
        value: 'pluginLoaded'
      }));
      $('body').append(this.$wacom_object);
      this.sketch_listener = new SketchListener(opts);
      this.$fg_canvas = this.sketch_listener.$canvas;
      this.sketch_listener.addCallback('onCanvasMouseUp', this.process_mouse_up);
      this.sketch_listener.addCallback('onCanvasMouseMove', this.process_mouse_move);
      this.sketch_listener.addCallback('onCanvasMouseDown', this.process_mouse_down);
      this.sketch_listener.addCallback('onCanvasMouseHover', this.show_tool_size);
      this.sketch_listener.addCallback('onCanvasMouseOut', this.refresh);
      this.$bg_canvas = $('<canvas>', opts).attr('width', opts['width']).attr('height', opts['height']);
    }

    SketchyPad.prototype.getPressure = function() {
      return document.getElementById('wtPlugin').penAPI.pressure;
    };

    SketchyPad.prototype.captureStart = function() {
      return this.sketch_listener.start();
    };

    SketchyPad.prototype.captureStop = function() {
      return this.sketch_listener.stop();
    };

    SketchyPad.prototype.show_tool_size = function() {
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      return Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
    };

    SketchyPad.prototype.process_mouse_down = function() {
      this.redoData = [];
      this.startTime = new Date().getTime();
      this.strokeData.push([this.sketch_listener.mouseCoord.x, this.sketch_listener.mouseCoord.y, this.getPressure(), 0]);
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
      return Renderer.drawStroke(this.feedback_ctx, [this.selected_tool, this.tool_size, this.strokeData]);
    };

    SketchyPad.prototype.process_mouse_move = function() {
      console.log(this.getPressure());
      this.elapsed_time = (new Date().getTime()) - this.startTime;
      this.strokeData.push([this.sketch_listener.mouseCoord.x, this.sketch_listener.mouseCoord.y, this.getPressure(), this.elapsed_time]);
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
      return Renderer.drawStroke(this.feedback_ctx, [this.selected_tool, this.tool_size, this.strokeData]);
    };

    SketchyPad.prototype.process_mouse_up = function() {
      this.sketchData.push([this.selected_tool, this.tool_size, this.strokeData]);
      this.strokeData = [];
      return Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
    };

    SketchyPad.prototype.refresh = function() {
      Renderer.clear(this.feedback_ctx, this.width, this.height);
      return Renderer.applyStrokes(this.feedback_ctx, this.sketchData);
    };

    SketchyPad.prototype.reset = function() {
      this.sketchData = [];
      return this.strokeData = [];
    };

    return SketchyPad;

  })();

  root.SketchyPad = SketchyPad;

  (function($, window, document) {
    var $this, methods, _anotherState, _flag, _internals, _listening_layer, _settings;
    $this = void 0;
    _settings = {
      "default": 'cool!'
    };
    _flag = false;
    _anotherState = null;
    _listening_layer = null;
    methods = {
      init: function(options) {
        var opts;
        $this = $(this);
        opts = {
          width: $this.width(),
          height: $this.height()
        };
        _listening_layer = new SketchyPad(opts);
        $this.prepend(_listening_layer.$canvas);
        _listening_layer.captureStart();
        $.extend(_settings, options || {});
        return $this;
      },
      doSomething: function(what) {
        return $this;
      },
      destroy: function() {
        console.log('calling destroy');
        _listening_layer.captureStop();
        _listening_layer.$canvas.remove();
        return $this;
      }
    };
    _internals = {
      toggleFlag: function() {
        return _flag = !_flag;
      },
      computeSomething: function(state, flag) {
        return flag != null ? flag : {
          state: "No, that's not right."
        };
      }
    };
    return $.fn.sketchyPad = function(method) {
      console.log(method);
      if (methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
      } else if (typeof method === "object" || !method) {
        return methods.init.apply(this, arguments);
      } else {
        return $.error("Method " + method + " does not exist on jquery.sketchyPad");
      }
    };
  })(jQuery, window, document);

}).call(this);
